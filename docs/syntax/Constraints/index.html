<!DOCTYPE html><head><meta charset="UTF-8"><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script><title>Constraints System|RACCOON</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon/index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="b35ebe1c-0e5b-4138-9dda-6a318a8525e2"><i class="material-icons">menu</i></a><ul class="sidenav" id="b35ebe1c-0e5b-4138-9dda-6a318a8525e2"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon/index.html" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Constraints</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="cffe8c33-9480-4c71-a063-8c7cc1621c2b" data-section-level="1" data-section-text="Constraints System"><h1 id="constraints-system">Constraints System</h1><section class="scrollspy" id="c8323b81-383c-43ae-a3f9-574424350618" data-section-level="2" data-section-text="MortarConstraints"><h2 id="mortarconstraints">MortarConstraints</h2><section id="6fe3c866-53c1-4705-9a3f-fe8b3a10caa4" data-section-level="3" data-section-text="Overview"><h3 id="overview">Overview</h3><p>An excellent overview of the conservative mortar constraint implementation in MOOSE is given in <a href="#osti_1468630">Peterson (2018)</a>. We have verified that the MOOSE mortar implementation satisfies <em>a priori</em> error estimates (see discussion and plots on <a href="https://github.com/idaholab/moose/issues/13080">this github issue</a>):</p><div form="['center', 'center', 'center', 'center']" recursive="True" class="moose-table-div"><table><thead><tr><th style=";text-align:center">Primal FE Type</th><th style=";text-align:center">Lagrange Multiplier (LM) FE Type</th><th style=";text-align:center">Primal L2 Convergence Rate</th><th style=";text-align:center">LM L2 Convergence Rate</th></tr></thead><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">3</td><td style=";text-align:center">2.5</td></tr></tbody><tbody><tr><td style=";text-align:center">Second order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">3</td><td style=";text-align:center">1</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody><tbody><tr><td style=";text-align:center">First order Lagrange</td><td style=";text-align:center">Constant monomial</td><td style=";text-align:center">2</td><td style=";text-align:center">1.5</td></tr></tbody></table></div></section><section id="facf6ffe-0d4c-44ed-9daf-0cd8b0237d83" data-section-level="3" data-section-text="Parameters"><h3 id="parameters">Parameters</h3><p>There are four required parameters the user will always have to supply for a constraint derived from <code>MortarConstraint</code>:</p><ul class="browser-default"><li><p><code>master_boundary</code>: the boundary name or ID assigned to the master side of the mortar interface </p></li><li><p><code>slave_boundary</code>: the boundary name or ID assigned to the slave side of the mortar interface </p></li><li><p><code>master_subdomain</code>: the subdomain name or ID assigned to the lower-dimesional block on the master side of the mortar interface </p></li><li><p><code>slave_boundary</code>: the subdomain name or ID assigned to the lower-dimensional block on the slave side of the mortar interface</p></li></ul><p>As suggested by the above required parameters, the user must do some mesh work before they can use a <code>MortarConstraint</code> object. The easiest way to prepare the mesh is to assign boundary IDs to the slave and master sides of the interface when creating the mesh in their 3rd-party meshing software (e.g. Cubit or Gmsh). If these boundary IDs exist, then the lower dimensional blocks can be generated automatically using the <code>LowerDBlockFromSideset</code> mesh modifiers as shown in the below input file snippet:</p><pre class="moose-pre"><code class="language-text">
[MeshModifiers]
  [./master]
    type = LowerDBlockFromSideset
    sidesets = &#x27;2&#x27;
    new_block_id = &#x27;20&#x27;
  [../]
  [./slave]
    type = LowerDBlockFromSideset
    sidesets = &#x27;1&#x27;
    new_block_id = &#x27;10&#x27;
  [../]
[]
</code></pre><p>There are also some optional parameters that can be supplied to <code>MortarConstraints</code>. They are:</p><ul class="browser-default"><li><p><code>variable</code>: Corresponds to a Lagrange Multipler variable that lives on the lower dimensional block on the slave face </p></li><li><p><code>slave_variable</code>: Primal variable on the slave side of the mortar interface (lives on the interior elements) </p></li><li><p><code>master_variable</code>: Primal variable on the master side of the mortar interface (lives on the interior elements). Most often <code>slave_variable</code> and <code>master_variable</code> will correspond to the same variable </p></li><li><p><code>compute_lm_residuals</code>: Whether to compute Lagrange Multiplier residuals. This will automatically be set to false if a <code>variable</code> parameter is not supplied. Other cases where the user may want to set this to false is when a different geometric algorithm is used for computing residuals for the LM and primal variables. For example, in mechanical contact the Karush-Kuhn-Tucker conditions may be enforced at nodes (through perhaps a <code>NodeFaceConstraint</code>) whereas the contact forces may be applied to the displacement residuals through <code>MortarConstraint</code> </p></li><li><p><code>compute_primal_residuals</code>: Whether to compute residuals for the primal variables. Again this may be a useful parameter to use when applying different geometric algorithms for computing residuals for LM variables and primal variables. </p></li><li><p><code>periodic</code>: Whether this constraint is going to be used to enforce a periodic condition. This has the effect of changing the normals vector, for mortar projection, from outward to inward facing.</p></li></ul><p>At present, either the <code>slave_variable</code> or <code>master_variable</code> parameter must be supplied.</p></section><section id="2f8c313b-5c18-42fa-9920-72ec49893975" data-section-level="3" data-section-text="Limitations"><h3 id="limitations">Limitations</h3><p>Unfortunately the mortar system does not currently work in three dimensions. It is on the to-do list, but it will require a significant amount of work to get all the projections correct.</p></section></section><section class="scrollspy" id="7752cea0-bbc9-4693-989a-9b1cabcc8966" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/constraints/CoupledTiedValueConstraint.html">CoupledTiedValueConstraint</a></li><li class="collection-item"><a href="../../source/constraints/EqualGradientConstraint.html">EqualGradientConstraint</a>EqualGradientConstraint enforces continuity of a gradient component between slave and master sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueBoundaryConstraint.html">EqualValueBoundaryConstraint</a></li><li class="collection-item"><a href="../../source/constraints/EqualValueConstraint.html">EqualValueConstraint</a>EqualValueConstraint enforces solution continuity between slave and master sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/EqualValueEmbeddedConstraint.html">EqualValueEmbeddedConstraint</a>This is a constraint enforcing overlapping portions of two blocks to have the same variable value</li><li class="collection-item"><a href="../../source/constraints/LinearNodalConstraint.html">LinearNodalConstraint</a>Constrains slave node to move as a linear combination of master nodes.</li><li class="collection-item"><a href="../../source/constraints/NormalMortarMechanicalContact.html">NormalMortarMechanicalContact</a>This class is used to apply normal contact forces using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/NormalNodalLMMechanicalContact.html">NormalNodalLMMechanicalContact</a>Implements the KKT conditions for normal contact using an NCP function. Requires that either the gap distance or the normal contact pressure (represented by the value of <code>variable</code>) is zero. The LM variable must be of the same order as the mesh</li><li class="collection-item"><a href="../../source/constraints/OldEqualValueConstraint.html">OldEqualValueConstraint</a>OldEqualValueConstraint enforces solution continuity between slave and master sides of a mortar interface using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/TangentialMortarLMMechanicalContact.html">TangentialMortarLMMechanicalContact</a>Ensures that the Karush-Kuhn-Tucker conditions of Coulomb frictional contact are satisfied</li><li class="collection-item"><a href="../../source/constraints/TangentialMortarMechanicalContact.html">TangentialMortarMechanicalContact</a>Used to apply tangential stresses from frictional contact using lagrange multipliers</li><li class="collection-item"><a href="../../source/constraints/TiedValueConstraint.html">TiedValueConstraint</a></li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="../../source/constraints/GapConductanceConstraint.html">GapConductanceConstraint</a>Computes the residual and Jacobian contributions for the &#x27;Lagrange Multiplier&#x27; implementation of the thermal contact problem. For more information, see the detailed description here: http://tinyurl.com/gmmhbe9</li><li class="collection-header">Contact App</li><li class="collection-item"><a href="../../source/constraints/GluedContactConstraint.html">GluedContactConstraint</a></li><li class="collection-item"><a href="../../source/constraints/MechanicalContactConstraint.html">MechanicalContactConstraint</a></li><li class="collection-item"><a href="../../source/constraints/MultiDContactConstraint.html">MultiDContactConstraint</a></li><li class="collection-item"><a href="../../source/constraints/NormalMortarLMMechanicalContact.html">NormalMortarLMMechanicalContact</a></li><li class="collection-item"><a href="../../source/constraints/NormalNodalMechanicalContact.html">NormalNodalMechanicalContact</a></li><li class="collection-item"><a href="../../source/constraints/OneDContactConstraint.html">OneDContactConstraint</a></li><li class="collection-item"><a href="../../source/constraints/RANFSNormalMechanicalContact.html">RANFSNormalMechanicalContact</a>Applies the Reduced Active Nonlinear Function Set scheme in which the slave node&#x27;s non-linear residual function is replaced by the zero penetration constraint equation when the constraint is active</li><li class="collection-item"><a href="../../source/constraints/SparsityBasedContactConstraint.html">SparsityBasedContactConstraint</a></li><li class="collection-item"><a href="../../source/constraints/TangentialNodalLMMechanicalContact.html">TangentialNodalLMMechanicalContact</a>Implements the KKT conditions for frictional Coulomb contact using an NCP function. Requires that either the relative tangential velocity is zero or the tangential stress is equal to the friction coefficient times the normal contact pressure.</li></ul></section><section class="scrollspy" id="38b77437-31ce-4a1e-a5ed-35bcbb54e337" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddConstraintAction.html">AddConstraintAction</a></li></ul><div class="moose-bibliography"><ol><li id="osti_1468630">John&nbsp;W. Peterson.
Progress toward a new implementation of the mortar finite element method in moose.
2 2018.
<a href="https://doi.org/10.2172/1468630">doi:10.2172/1468630</a>.<a href="#a5e708f4-701b-434b-af17-3bb0a777404c" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="a5e708f4-701b-434b-af17-3bb0a777404c"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{osti_1468630,
    author = "Peterson, John W.",
    title = "Progress toward a new implementation of the mortar finite element method in MOOSE",
    abstractNote = {The mortar finite element method has been used for many years in a variety of applications, including the enforcement of continuity conditions across decomposed domains, the implementation of Dirichlet boundary conditions, obtaining improved estimates of surface fluxes, and for solving large deformation contact mechanics problems. There is a currently great deal of interest in developing more robust mechanical and thermal contact solution strategies in the MOOSE framework and physics modules, and schemes based on the mortar finite element approach appear to be a promising avenue of development. There are a number of challenges associated with the development of a robust Lagrange multiplier based formulation of the mortar finite element method which can be tackled using the relatively simple framework of thermal contact problems, before tackling more complicated applications such as thermomechanical contact. In this report, we describe several aspects of our mortar finite element method implementation for solving thermal contact problems. The approach and notation used are based primarily based on the work of Bin Yang et al. ("Two dimensional mortar contact methods for large deformation frictional sliding," International Journal for Numerical Methods in Engineering 62(9), 2005).},
    doi = "10.2172/1468630",
    journal = "",
    place = "United States",
    year = "2018",
    month = "2"
}
</code></pre></div></div></li></ol></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#c8323b81-383c-43ae-a3f9-574424350618" class="tooltipped" data-position="left" data-tooltip="MortarConstraints">MortarConstraints</a></li><li><a href="#7752cea0-bbc9-4693-989a-9b1cabcc8966" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#38b77437-31ce-4a1e-a5ed-35bcbb54e337" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>