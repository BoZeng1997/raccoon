<!DOCTYPE html><head><meta charset="UTF-8"><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script><script type="text/javascript" src="../../contrib/plotly/plotly.min.js"></script><title>Coupleable|RACCOON</title></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="https://hugary1995.github.io/raccoon" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="0a863358-a6cc-4f47-9db9-bff089266701"><i class="material-icons">menu</i></a><ul class="sidenav" id="0a863358-a6cc-4f47-9db9-bff089266701"><li><a href="../../install/index.html">Install</a></li><li><a href="../../examples/index.html">Examples</a></li><li><a href="../../theory/index.html">Theory</a></li><li><a href="../../documentation/index.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="https://hugary1995.github.io/raccoon" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">source</a><span class="breadcrumb">interfaces</span><a href="#" class="breadcrumb">Coupleable</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="c7936b5c-4cf2-45d9-98fa-cfff8beb546e" data-section-level="1" data-section-text="Coupleable"><h1 id="coupleable">Coupleable</h1><p>This class provides API for coupling different kinds of variables values into MOOSE systems. The following table summarizes the methods and kinds of values they provide:</p><div form="['center', 'center']" recursive="True" class="moose-table-div"><table><thead><tr><th style=";text-align:center">Method</th><th style=";text-align:center">Description</th></tr></thead><tbody><tr><td style=";text-align:center">coupledValue</td><td style=";text-align:center">Values of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledGradient</td><td style=";text-align:center">Gradients of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledSecond</td><td style=";text-align:center">Second derivatives of a coupled variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledNodalValue</td><td style=";text-align:center">Values of a coupled variable at nodes.</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorValue</td><td style=";text-align:center">Values of a coupled vector variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledCurl</td><td style=";text-align:center">Curl of a coupled vector variable in q-points</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledDot</td><td style=";text-align:center">Time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledDotDu</td><td style=";text-align:center">Derivative of a time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledNodalDot</td><td style=";text-align:center">Nodal value of the time derivative of a coupled variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorDot</td><td style=";text-align:center">Time derivative of a coupled vector variable</td></tr></tbody><tbody><tr><td style=";text-align:center">coupledVectorDotDu</td><td style=";text-align:center">Derivative of a time derivative of a coupled vector variable</td></tr></tbody></table></div><p>For values, gradients and second derivatives, users can request old and older values in case they are running a transient simulation. In case of old and older values, the methods are called <code>coupledValueOld</code> and <code>coupledValueOlder</code>, respectively. Similarly,</p><section class="scrollspy" id="b8d34709-da12-41a0-aaed-0e78ccdcfaa5" data-section-level="2" data-section-text="Optional Coupling"><h2 id="optional-coupling">Optional Coupling</h2><p>To determine if a variable was coupled, users can use <code>isCoupled</code> method. The typical use case looks like this:</p><pre class="moose-pre"><code class="language-text">
_value(isCoupled(&quot;v&quot;) ? coupledValue(&quot;v&quot;) : _zero)
</code></pre><p>However, this use case became obsolete and now it is recommended to use default values for optionally coupled variables, see the following example:</p><pre class="moose-pre"><code class="language-text">
validParams&lt;Class&gt;()
{
  InputParameters params = validParams&lt;BaseClass&gt;();
  params.addCoupledVar(&quot;v&quot;, 2., &quot;Coupled value&quot;);
  ...
}

Class::Class(...) : BaseClass(...),
  _v(coupledValue(&#x27;v&#x27;))
</code></pre><p>The advantage here is that users can provide arbitrary default values to their variables.</p></section><section class="scrollspy" id="7fd55fa7-db01-4666-8ba8-00b8948c63d9" data-section-level="2" data-section-text="Coupling of Vectors of Variables"><h2 id="coupling-of-vectors-of-variables">Coupling of Vectors of Variables</h2><p>Users can couple a vector of variables using the following syntax:</p><pre class="moose-pre"><code class="language-text">
v = &#x27;a b c&#x27;
</code></pre><p>This syntax provides 3 variables coupled as a variable <code>v</code> in a MOOSE object using the <code>Coupleable</code> interface. The number of components coupled into can be obtained by <code>coupledComponents</code> method. Then, individual components can be obtained by calling <code>coupledValue</code> (or any other method mentioned above) passing in the variable name (as usual) and the component index. See the following example:</p><p>Declarations:</p><pre class="moose-pre"><code class="language-text">
class B : public A
{
  ...
protected:
  unsigned int _n_vars;
  std::vector&lt;MooseVariable *&gt; _vars;
};
</code></pre><p>Implementation:</p><pre class="moose-pre"><code class="language-text">
validParams&lt;B&gt;()
{
  InputParameters params = validParams&lt;A&gt;();
  params.addRequiredCoupledVar(&quot;v&quot;, &quot;Coupled value&quot;);
  ...
}

B::B(...) : A(...),
  _n_vars(coupledComponents(&quot;v&quot;))
{
  for (unsigned int i = 0; i &lt; _n_vars; i++)
    _vars.push_back(dynamic_cast&lt;MooseVariable *&gt;(getVar(&quot;v&quot;, i)));
}
</code></pre></section><section class="scrollspy" id="3cf55b35-2d7f-4bb3-bb31-422181418e14" data-section-level="2" data-section-text="Defaults for Coupling of Vectors of Variables"><h2 id="defaults-for-coupling-of-vectors-of-variables">Defaults for Coupling of Vectors of Variables</h2><p>Vectors of variables can be added using <code>params.addCoupledVar</code> as described above. The parameter class allows providing defaults for vector variables as follows:</p><pre class="moose-pre"><code class="language-text">
validParams&lt;B&gt;()
{
  InputParameters params = validParams&lt;A&gt;();
  params.addCoupledVar(&quot;v&quot;, {1, 2, 3}, &quot;Coupled value&quot;);
  ...
}
</code></pre><p>Coupled variable parameters can be set to constant real numbers in the input file using the syntax</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1&#x27;
</code></pre><p>for a single coupled variable or using</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1 2 3&#x27;
</code></pre><p>for a vector of coupled variables. Currently mixing actual variable assignments and defaults like this:</p><pre class="moose-pre"><code class="language-text">
v = &#x27;1 actual_var 3&#x27;
</code></pre><p>is not supported.</p></section><section class="scrollspy" id="71801ec9-0905-42da-9a55-08047fda5d52" data-section-level="2" data-section-text="Coupled Solution DOFs"><h2 id="coupled-solution-dofs">Coupled Solution DOFs</h2><p>It is possible to retrieve the solution DOFs of an element in an elemental loop. This is different than the &quot;value&quot; type coupling which holds the interpolated values of the shape functions themselves. Obtaining the raw DOFs all the user to perform their own integration or other evaluation without going through the interpolation process. These functions can be found here:</p><pre class="moose-pre"><code class="language-cpp">  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0);

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0);

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0);
</code></pre><a href="#fe4bf631-5852-4b4a-ae99-084fa7d7d50b" class="modal-trigger">(../moose/framework/include/interfaces/Coupleable.h)</a><div class="modal moose-modal" id="fe4bf631-5852-4b4a-ae99-084fa7d7d50b"><div class="modal-content"><h4>/home/gary/projects/moose/framework/include/interfaces/Coupleable.h</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &lt;unordered_map&gt;
#include &quot;MooseTypes.h&quot;
#include &quot;MooseArray.h&quot;
#include &quot;MooseVariableFE.h&quot;
#include &quot;InputParameters.h&quot;

#define usingCoupleableMembers                                                                     \
  using Coupleable::_zero;                                                                         \
  using Coupleable::_grad_zero;                                                                    \
  using Coupleable::_coupled_standard_moose_vars;                                                  \
  using Coupleable::isCoupled;                                                                     \
  using Coupleable::coupledComponents;                                                             \
  using Coupleable::coupled;                                                                       \
  using Coupleable::coupledValue;                                                                  \
  using Coupleable::coupledValueOld;                                                               \
  using Coupleable::coupledValueOlder;                                                             \
  using Coupleable::coupledGradient;                                                               \
  using Coupleable::coupledGradientOld;                                                            \
  using Coupleable::coupledGradientOlder;                                                          \
  using Coupleable::getVar

// Forward declarations
class MooseVariableScalar;
class MooseObject;

namespace libMesh
{
template &lt;typename T&gt;
class DenseVector;
}

#define adCoupledValue this-&gt;template adCoupledValueTemplate&lt;compute_stage&gt;
#define adCoupledGradient this-&gt;template adCoupledGradientTemplate&lt;compute_stage&gt;
#define adCoupledSecond this-&gt;template adCoupledSecondTemplate&lt;compute_stage&gt;
#define adCoupledDot this-&gt;template adCoupledDotTemplate&lt;compute_stage&gt;
#define adCoupledVectorDot this-&gt;template adCoupledVectorDotTemplate&lt;compute_stage&gt;
#define adCoupledVectorValue this-&gt;template adCoupledVectorValueTemplate&lt;compute_stage&gt;
#define adCoupledVectorGradient this-&gt;template adCoupledVectorGradientTemplate&lt;compute_stage&gt;
#define adCoupledVectorSecond this-&gt;template adCoupledVectorSecondTemplate&lt;compute_stage&gt;
#define adZeroValue this-&gt;template adZeroValueTemplate&lt;compute_stage&gt;
#define adZeroGradient this-&gt;template adZeroGradientTemplate&lt;compute_stage&gt;
#define adZeroSecond this-&gt;template adZeroSecondTemplate&lt;compute_stage&gt;
#define adCoupledNodalValue this-&gt;template adCoupledNodalValueTemplate&lt;Real, compute_stage&gt;
#define adCoupledNodalVectorValue                                                                  \
  this-&gt;template adCoupledNodalValueTemplate&lt;RealVectorValue, compute_stage&gt;

/**
 * Interface for objects that needs coupling capabilities
 *
 */
class Coupleable
{
public:
  /**
   * Constructing the object
   * @param parameters Parameters that come from constructing the object
   * @param nodal true if we need to couple with nodal values, otherwise false
   */
  Coupleable(const MooseObject * moose_object, bool nodal);

  /**
   * Get the list of coupled variables
   * @return The list of coupled variables
   */
  const std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFEBase *&gt;&gt; &amp; getCoupledVars()
  {
    return _coupled_vars;
  }

  /**
   * Get the list of all coupled variables
   * @return The list of all coupled variables
   */
  const std::vector&lt;MooseVariableFEBase *&gt; &amp; getCoupledMooseVars() const
  {
    return _coupled_moose_vars;
  }

  /**
   * Get the list of standard coupled variables
   * @return The list of standard coupled variables
   */
  const std::vector&lt;MooseVariable *&gt; &amp; getCoupledStandardMooseVars() const
  {
    return _coupled_standard_moose_vars;
  }

  /**
   * Get the list of vector coupled variables
   * @return The list of vector coupled variables
   */
  const std::vector&lt;VectorMooseVariable *&gt; &amp; getCoupledVectorMooseVars() const
  {
    return _coupled_vector_moose_vars;
  }

  /**
   * Get the list of array coupled variables
   * @return The list of array coupled variables
   */
  const std::vector&lt;ArrayMooseVariable *&gt; &amp; getCoupledArratMooseVars() const
  {
    return _coupled_array_moose_vars;
  }

  void addFEVariableCoupleableVectorTag(TagID tag) { _fe_coupleable_vector_tags.insert(tag); }

  void addFEVariableCoupleableMatrixTag(TagID tag) { _fe_coupleable_matrix_tags.insert(tag); }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableVectorTags() { return _fe_coupleable_vector_tags; }

  std::set&lt;TagID&gt; &amp; getFEVariableCoupleableMatrixTags() { return _fe_coupleable_matrix_tags; }

protected:
  /**
   * A call-back function provided by the derived object for actions before coupling a variable
   * with functions such as coupledValue.
   */
  virtual void coupledCallback(const std::string &amp; /*var_name*/, bool /*is_old*/) {}

  /**
   * Returns true if a variables has been coupled as name.
   * @param var_name The name the kernel wants to refer to the variable as.
   * @param i By default 0, in general the index to test in a vector of MooseVariable pointers.
   * @return True if a coupled variable has the supplied name
   */
  virtual bool isCoupled(const std::string &amp; var_name, unsigned int i = 0);

  /**
   * Number of coupled components
   * @param var_name Name of the variable
   * @return number of components this variable has (usually 1)
   */
  unsigned int coupledComponents(const std::string &amp; var_name);

  /**
   * Returns the index for a coupled variable by name
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Index of coupled variable, if this is an optionally coupled variable that wasn&#x27;t
   * provided this will return a unique &quot;invalid&quot; index.
   */
  virtual unsigned int coupled(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns value of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp; coupledValue(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns value of a coupled variable for use in Automatic Differentiation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableValue &amp; adCoupledValueTemplate(const std::string &amp; var_name,
                                                 unsigned int comp = 0);

  /**
   * Returns value of a coupled vector variable for use in Automatic Differentiation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVectorVariableValue &amp; adCoupledVectorValueTemplate(const std::string &amp; var_name,
                                                             unsigned int comp = 0);

  /**
   * Returns value of a coupled variable for a given tag
   * @param var_name Name of coupled variable
   * @param tag vector tag ID
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledVectorTagValue(const std::string &amp; var_name, TagID tag, unsigned int comp = 0);

  /**
   * Returns value of a coupled variable for a given tag. This couples the diag vector of matrix
   * @param var_name Name of coupled variable
   * @param tag matrix tag ID
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::_u
   */
  virtual const VariableValue &amp;
  coupledMatrixTagValue(const std::string &amp; var_name, TagID tag, unsigned int comp = 0);

  /**
   * Returns value of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue for the coupled vector variable
   * @see VectorKernel::_u
   */
  virtual const VectorVariableValue &amp; coupledVectorValue(const std::string &amp; var_name,
                                                         unsigned int comp = 0);

  /**
   * Returns value of a coupled array variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a ArrayVariableValue for the coupled vector variable
   * @see ArrayKernel::_u
   */
  virtual const ArrayVariableValue &amp; coupledArrayValue(const std::string &amp; var_name,
                                                       unsigned int comp = 0);

  /**
   * Returns a *writable* reference to a coupled variable.  Note: you
   * should not have to use this very often (use coupledValue()
   * instead) but there are situations, such as writing to multiple
   * AuxVariables from a single AuxKernel, where it is required.
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   * @see Kernel::value
   */
  virtual VariableValue &amp; writableCoupledValue(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns an old value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   * @see Kernel::valueOld
   */
  virtual const VariableValue &amp; coupledValueOld(const std::string &amp; var_name,
                                                unsigned int comp = 0);

  /**
   * Returns an old value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   * @see Kernel::valueOlder
   */
  virtual const VariableValue &amp; coupledValueOlder(const std::string &amp; var_name,
                                                  unsigned int comp = 0);

  /**
   * Returns value of previous Newton iterate of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  virtual const VariableValue &amp; coupledValuePreviousNL(const std::string &amp; var_name,
                                                       unsigned int comp = 0);

  /**
   * Returns an old value from previous time step  of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the old value of the coupled variable
   * @see VectorKernel::_u_old
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOld(const std::string &amp; var_name,
                                                            unsigned int comp = 0);

  /**
   * Returns an old value from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableValue containing the older value of the coupled variable
   * @see VectorKernel::_u_older
   */
  virtual const VectorVariableValue &amp; coupledVectorValueOlder(const std::string &amp; var_name,
                                                              unsigned int comp = 0);

  /**
   * Returns an old value from previous time step  of a coupled array variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ArrayVariableValue containing the old value of the coupled variable
   * @see ArrayKernel::_u_old
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0);

  /**
   * Returns an old value from two time steps previous of a coupled array variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a ArrayVariableValue containing the older value of the coupled variable
   * @see ArrayKernel::_u_older
   */
  virtual const ArrayVariableValue &amp; coupledArrayValueOlder(const std::string &amp; var_name,
                                                            unsigned int comp = 0);

  /**
   * Returns gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  virtual const VariableGradient &amp; coupledGradient(const std::string &amp; var_name,
                                                   unsigned int comp = 0);

  /**
   * Returns gradient of a coupled variable for use in Automatic Differentation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableGradient &amp; adCoupledGradientTemplate(const std::string &amp; var_name,
                                                       unsigned int comp = 0);

  /**
   * Returns gradient of a coupled vector variable for use in Automatic Differentation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled variable
   * @see Kernel::gradient
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVectorVariableGradient &amp; adCoupledVectorGradientTemplate(const std::string &amp; var_name,
                                                                   unsigned int comp = 0);

  /**
   * Returns second derivatives of a coupled variable for use in Automatic Differentation
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivatives of the coupled variable
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableSecond &amp; adCoupledSecondTemplate(const std::string &amp; var_name,
                                                   unsigned int comp = 0);

  /**
   * Returns second derivatives of a coupled vector variable for use in Automatic Differentation
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableSecond containing the second derivatives of the coupled
   * variable
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVectorVariableSecond &amp; adCoupledVectorSecondTemplate(const std::string &amp; var_name,
                                                               unsigned int comp = 0);

  /**
   * Returns an old gradient from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the old gradient of the coupled variable
   * @see Kernel::gradientOld
   */
  virtual const VariableGradient &amp; coupledGradientOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0);

  /**
   * Returns an old gradient from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the older gradient of the coupled variable
   * @see Kernel::gradientOlder
   */
  virtual const VariableGradient &amp; coupledGradientOlder(const std::string &amp; var_name,
                                                        unsigned int comp = 0);

  /**
   * Returns gradient of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the gradient of the coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientPreviousNL(const std::string &amp; var_name,
                                                             unsigned int comp = 0);

  /**
   * Time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDot(const std::string &amp; var_name,
                                                      unsigned int comp = 0);

  /**
   * Second time derivative of the gradient of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableGradient containing the time derivative of the gradient of a
   * coupled variable
   */
  virtual const VariableGradient &amp; coupledGradientDotDot(const std::string &amp; var_name,
                                                         unsigned int comp = 0);

  /**
   * Returns gradient of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradient(const std::string &amp; var_name,
                                                               unsigned int comp = 0);

  /**
   * Returns an old gradient from previous time step of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled vector
   * variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOld(const std::string &amp; var_name,
                                                                  unsigned int comp = 0);

  /**
   * Returns an old gradient from two time steps previous of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableGradient containing the older gradient of the coupled
   * vector variable
   */
  virtual const VectorVariableGradient &amp; coupledVectorGradientOlder(const std::string &amp; var_name,
                                                                    unsigned int comp = 0);

  /**
   * Returns gradient of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradient(const std::string &amp; var_name,
                                                             unsigned int comp = 0);

  /**
   * Returns an old gradient from previous time step of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a VectorVariableGradient containing the old gradient of the coupled array
   * variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOld(const std::string &amp; var_name,
                                                                unsigned int comp = 0);

  /**
   * Returns an old gradient from two time steps previous of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableGradient containing the older gradient of the coupled
   * array variable
   */
  virtual const ArrayVariableGradient &amp; coupledArrayGradientOlder(const std::string &amp; var_name,
                                                                  unsigned int comp = 0);

  /**
   * Returns curl of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the curl of the coupled variable
   * @see Kernel::_curl_u
   */
  virtual const VectorVariableCurl &amp; coupledCurl(const std::string &amp; var_name,
                                                 unsigned int comp = 0);

  /**
   * Returns an old curl from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the old curl of the coupled variable
   * @see Kernel::_curl_u_old
   */
  virtual const VectorVariableCurl &amp; coupledCurlOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0);

  /**
   * Returns an old curl from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VectorVariableCurl containing the older curl of the coupled variable
   * @see Kernel::_curl_u_older
   */
  virtual const VectorVariableCurl &amp; coupledCurlOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0);

  /**
   * Returns second derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   * @see Kernel::second
   */
  virtual const VariableSecond &amp; coupledSecond(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns an old second derivative from previous time step of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the old second derivative of the coupled
   * variable
   * @see Kernel::secondOld
   */
  virtual const VariableSecond &amp; coupledSecondOld(const std::string &amp; var_name,
                                                  unsigned int comp = 0);

  /**
   * Returns an old second derivative from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the older second derivative of the coupled
   * variable
   * @see Kernel::secondOlder
   */
  virtual const VariableSecond &amp; coupledSecondOlder(const std::string &amp; var_name,
                                                    unsigned int comp = 0);

  /**
   * Returns second derivative of a coupled variable for the previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableSecond containing the second derivative of the coupled variable
   */
  virtual const VariableSecond &amp; coupledSecondPreviousNL(const std::string &amp; var_name,
                                                         unsigned int comp = 0);

  /**
   * Time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDot(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDotDot(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDotOld(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   */
  virtual const VariableValue &amp; coupledDotDotOld(const std::string &amp; var_name,
                                                 unsigned int comp = 0);

  /**
   * Time derivative of a coupled variable for ad simulations
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * @see Kernel::dot
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableValue &amp; adCoupledDotTemplate(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Time derivative of a vector coupled variable for ad simulations
   * @param var_name Name of vector coupled variable
   * @param comp Component number
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   * @see Kernel::dot
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVectorVariableValue &amp; adCoupledVectorDotTemplate(const std::string &amp; var_name,
                                                           unsigned int comp = 0);

  /**
   * Time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDot(const std::string &amp; var_name,
                                                       unsigned int comp = 0);

  /**
   * Second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDot(const std::string &amp; var_name,
                                                          unsigned int comp = 0);

  /**
   * Old time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotOld(const std::string &amp; var_name,
                                                          unsigned int comp = 0);

  /**
   * Old second time derivative of a coupled vector variable
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VectorVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const VectorVariableValue &amp; coupledVectorDotDotOld(const std::string &amp; var_name,
                                                             unsigned int comp = 0);

  /**
   * Time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled
   * vector variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDu(const std::string &amp; var_name,
                                                   unsigned int comp = 0);

  /**
   * Second time derivative of a coupled vector variable with respect to the coefficients
   * @param var_name Name of coupled vector variable
   * @param comp Component number for vector of coupled vector variables
   * @return Reference to a VariableValue containing the time derivative of the coupled vector
   * variable with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledVectorDotDotDu(const std::string &amp; var_name,
                                                      unsigned int comp = 0);

  /**
   * Time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDot(const std::string &amp; var_name,
                                                     unsigned int comp = 0);

  /**
   * Second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDot(const std::string &amp; var_name,
                                                        unsigned int comp = 0);

  /**
   * Old time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotOld(const std::string &amp; var_name,
                                                        unsigned int comp = 0);

  /**
   * Old second time derivative of a coupled array variable
   * @param var_name Name of coupled array variable
   * @param comp Component number for vector of coupled array variables
   * @return Reference to a ArrayVariableValue containing the time derivative of the coupled
   * variable
   */
  virtual const ArrayVariableValue &amp; coupledArrayDotDotOld(const std::string &amp; var_name,
                                                           unsigned int comp = 0);

  /**
   * Time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDu(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Second time derivative of a coupled variable with respect to the coefficients
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the time derivative of the coupled variable
   * with respect to the coefficients
   */
  virtual const VariableValue &amp; coupledDotDotDu(const std::string &amp; var_name,
                                                unsigned int comp = 0);

  /**
   * Returns nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValue(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns AD nodal values of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T, ComputeStage compute_stage&gt;
  const typename Moose::ValueType&lt;T, compute_stage&gt;::type &amp;
  adCoupledNodalValueTemplate(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns an old nodal value from previous time step  of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the old value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOld(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns an old nodal value from two time steps previous of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the older value of the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValueOlder(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Returns nodal values of a coupled variable for previous Newton iterate
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalValuePreviousNL(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Nodal values of time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  template &lt;typename T&gt;
  const T &amp; coupledNodalDot(const std::string &amp; var_name, unsigned int comp = 0);

  /**
   * Nodal values of second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDot(const std::string &amp; var_name,
                                                   unsigned int comp = 0);

  /**
   * Nodal values of old time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of time derivative of the
   * coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotOld(const std::string &amp; var_name,
                                                   unsigned int comp = 0);

  /**
   * Nodal values of old second time derivative of a coupled variable
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue containing the nodal values of second time derivative of
   * the coupled variable
   */
  virtual const VariableValue &amp; coupledNodalDotDotOld(const std::string &amp; var_name,
                                                      unsigned int comp = 0);
  // coupled-dof-values-begin
  /**
   * Returns DoFs in the current solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValues(const std::string &amp; var_name,
                                                 unsigned int comp = 0);

  /**
   * Returns DoFs in the old solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the old DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOld(const std::string &amp; var_name,
                                                    unsigned int comp = 0);

  /**
   * Returns DoFs in the older solution vector of a coupled variable for the local element
   * @param var_name Name of coupled variable
   * @param comp Component number for vector of coupled variables
   * @return Reference to a VariableValue for the older DoFs of the coupled variable
   */
  virtual const VariableValue &amp; coupledDofValuesOlder(const std::string &amp; var_name,
                                                      unsigned int comp = 0);
  // coupled-dof-values-end

  /**
   * Template method that returns _zero to RESIDUAL computing objects and _ad_zero to JACOBIAN
   * computing objects
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableValue &amp; adZeroValueTemplate();

  /**
   * Template method that returns _grad_zero to RESIDUAL computing objects and _ad_grad_zero to
   * JACOBIAN computing objects
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableGradient &amp; adZeroGradientTemplate();

  /**
   * Retrieve a zero second for automatic differentiation
   */
  template &lt;ComputeStage compute_stage&gt;
  const ADVariableSecond &amp; adZeroSecondTemplate();

protected:
  // Reference to the interface&#x27;s input parameters
  const InputParameters &amp; _c_parameters;

  /// The name of the object this interface is part of
  const std::string &amp; _c_name;

  // Reference to FEProblemBase
  FEProblemBase &amp; _c_fe_problem;

  /// Coupled vars whose values we provide
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableFEBase *&gt;&gt; _coupled_vars;

  /// Vector of all coupled variables
  std::vector&lt;MooseVariableFEBase *&gt; _coupled_moose_vars;

  /// Vector of standard coupled variables
  std::vector&lt;MooseVariable *&gt; _coupled_standard_moose_vars;

  /// Vector of vector coupled variables
  std::vector&lt;VectorMooseVariable *&gt; _coupled_vector_moose_vars;

  /// Vector of array coupled variables
  std::vector&lt;ArrayMooseVariable *&gt; _coupled_array_moose_vars;

  /// True if we provide coupling to nodal values
  bool _c_nodal;

  /// True if implicit value is required
  bool _c_is_implicit;

  /// Thread ID of the thread using this object
  THREAD_ID _c_tid;

  /// Will hold the default value for optional coupled variables.
  std::unordered_map&lt;std::string, std::vector&lt;std::unique_ptr&lt;VariableValue&gt;&gt;&gt; _default_value;

  /// Will hold the default value for optional coupled variables for automatic differentiation.
  std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;DualReal&gt;&gt;&gt; _ad_default_value;

  /// Will hold the default value for optional vector coupled variables.
  std::unordered_map&lt;std::string, std::unique_ptr&lt;VectorVariableValue&gt;&gt; _default_vector_value;

  /// Will hold the default value for optional array coupled variables.
  std::map&lt;std::string, ArrayVariableValue *&gt; _default_array_value;

  /// Will hold the default value for optional vector coupled variables for automatic differentiation.
  std::unordered_map&lt;std::string, std::unique_ptr&lt;MooseArray&lt;DualRealVectorValue&gt;&gt;&gt;
      _ad_default_vector_value;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  VariableValue _default_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  VariableGradient _default_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  MooseArray&lt;DualRealVectorValue&gt; _ad_default_gradient;

  /// This will always be zero because the default values for optionally coupled vector variables is always constant
  MooseArray&lt;DualRealTensorValue&gt; _ad_default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  VariableSecond _default_second;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  MooseArray&lt;DualRealTensorValue&gt; _ad_default_second;

  /// Zero value of a variable
  const VariableValue &amp; _zero;
  const MooseArray&lt;DualReal&gt; &amp; _ad_zero;

  /// Zero gradient of a variable
  const VariableGradient &amp; _grad_zero;
  const MooseArray&lt;DualRealVectorValue&gt; &amp; _ad_grad_zero;

  /// Zero second derivative of a variable
  const VariableSecond &amp; _second_zero;
  const MooseArray&lt;DualRealTensorValue&gt; &amp; _ad_second_zero;
  /// Zero second derivative of a test function
  const VariablePhiSecond &amp; _second_phi_zero;
  /// Zero value of a vector variable
  const VectorVariableValue &amp; _vector_zero;
  /// Zero value of the curl of a vector variable
  const VectorVariableCurl &amp; _vector_curl_zero;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  VectorVariableValue _default_vector_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  VectorVariableGradient _default_vector_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  VectorVariableCurl _default_vector_curl;

  /**
   * This will always be zero because the default values for optionally coupled variables is always
   * constant and this is used for time derivative info
   */
  ArrayVariableValue _default_array_value_zero;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  ArrayVariableGradient _default_array_gradient;

  /// This will always be zero because the default values for optionally coupled variables is always constant
  ArrayVariableCurl _default_array_curl;

  /**
   * Check that the right kind of variable is being coupled in
   *
   * @param var_name The name of the coupled variable
   */
  bool checkVar(const std::string &amp; var_name, unsigned int comp = 0, unsigned int comp_bound = 0);

private:
  enum class FuncAge
  {
    Curr,
    Old,
    Older,
  };

  enum class VarType
  {
    Ignore,
    Gradient,
    GradientDot,
    Dot,
  };

  void checkFuncType(const std::string var_name, VarType t, FuncAge age);

protected:
  /**
   * Extract pointer to a base finite element coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariableFEBase * getFEVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Helper that segues off to either getVar of getVectorVar depending on template paramter
   */
  template &lt;typename T&gt;
  MooseVariableFE&lt;T&gt; * getVarHelper(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  MooseVariable * getVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled vector variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  VectorMooseVariable * getVectorVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Extract pointer to a coupled array variable
   * @param var_name Name of parameter desired
   * @param comp Component number of multiple coupled variables
   * @return Pointer to the desired variable
   */
  ArrayMooseVariable * getArrayVar(const std::string &amp; var_name, unsigned int comp);

  /**
   * Checks to make sure that the current Executioner has set &quot;_is_transient&quot; when old/older values
   * are coupled in.
   * @param name the name of the variable
   * @param fn_name The name of the function that called this method - used in the error message
   */
  void validateExecutionerType(const std::string &amp; name, const std::string &amp; fn_name) const;

  /// Whether or not this object is a &quot;neighbor&quot; object: ie all of it&#x27;s coupled values should be neighbor values
  bool _coupleable_neighbor;

public:
  /**
   * Helper method to return (and insert if necessary) the default value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return VariableValue * a pointer to the associated VarirableValue.
   */
  template &lt;ComputeStage compute_stage&gt;
  ADVariableValue * getADDefaultValue(const std::string &amp; var_name);

  /**
   * Helper method to return (and insert if necessary) the default vector value for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return VariableVectorValue * a pointer to the associated VarirableVectorValue.
   */
  template &lt;ComputeStage compute_stage&gt;
  ADVectorVariableValue * getADDefaultVectorValue(const std::string &amp; var_name);

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default gradient
   * @return VariableGradient * a pointer to the associated VariableGradient.
   */
  template &lt;ComputeStage compute_stage&gt;
  ADVariableGradient &amp; getADDefaultGradient();

  /**
   * Helper method to return (and insert if necessary) the default gradient for Automatic
   * Differentiation for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default gradient
   * @return VariableGradient * a pointer to the associated VectorVariableGradient.
   */
  template &lt;ComputeStage compute_stage&gt;
  ADVectorVariableGradient &amp; getADDefaultVectorGradient();

  /**
   * Helper method to return (and insert if necessary) the default second derivatives for Automatic
   * Differentiation for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default second derivative
   * @return VariableSecond * a pointer to the associated VariableSecond.
   */
  template &lt;ComputeStage compute_stage&gt;
  ADVariableSecond &amp; getADDefaultSecond();

private:
  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled variable.
   * @param var_name the name of the variable for which to retrieve a default value
   * @return a pointer to the associated VariableValue.
   */
  VariableValue * getDefaultValue(const std::string &amp; var_name, unsigned int comp);

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled vector variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  VectorVariableValue * getDefaultVectorValue(const std::string &amp; var_name);

  /**
   * Helper method to return (and insert if necessary) the default value
   * for an uncoupled array variable.
   * @param var_name the name of the vector variable for which to retrieve a default value
   * @return a pointer to the associated VectorVariableValue.
   */
  ArrayVariableValue * getDefaultArrayValue(const std::string &amp; var_name);

  /**
   * Get nodal default value
   */
  template &lt;typename T&gt;
  const T &amp; getDefaultNodalValue(const std::string &amp; var_name, unsigned int comp = 0);

  /// Maximum qps for any element in this system
  unsigned int _coupleable_max_qps;

  /// Unique indices for optionally coupled vars that weren&#x27;t provided
  std::unordered_map&lt;std::string, std::vector&lt;unsigned int&gt;&gt; _optional_var_index;

  /// Scalar variables coupled into this object (for error checking)
  std::unordered_map&lt;std::string, std::vector&lt;MooseVariableScalar *&gt;&gt; _c_coupled_scalar_vars;

  std::set&lt;TagID&gt; _fe_coupleable_vector_tags;

  std::set&lt;TagID&gt; _fe_coupleable_matrix_tags;

private:
  const MooseObject * _obj;
};

template &lt;ComputeStage compute_stage&gt;
const ADVariableValue &amp;
Coupleable::adCoupledValueTemplate(const std::string &amp; var_name, unsigned int comp)
{
  MooseVariable * var = getVar(var_name, comp);
  if (!var)
    return *getADDefaultValue&lt;compute_stage&gt;(var_name);
  checkFuncType(var_name, VarType::Ignore, FuncAge::Curr);

  if (_c_nodal)
    mooseError(&quot;Not implemented&quot;);
  if (!_c_is_implicit)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adSln&lt;compute_stage&gt;();
  return var-&gt;adSlnNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVariableGradient &amp;
Coupleable::adCoupledGradientTemplate(const std::string &amp; var_name, unsigned int comp)
{
  MooseVariable * var = getVar(var_name, comp);
  if (!var)
    return getADDefaultGradient&lt;compute_stage&gt;();
  checkFuncType(var_name, VarType::Gradient, FuncAge::Curr);

  if (!_c_is_implicit)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adGradSln&lt;compute_stage&gt;();
  return var-&gt;adGradSlnNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVariableSecond &amp;
Coupleable::adCoupledSecondTemplate(const std::string &amp; var_name, unsigned int comp)
{
  MooseVariable * var = getVar(var_name, comp);
  if (!var)
    return getADDefaultSecond&lt;compute_stage&gt;();
  checkFuncType(var_name, VarType::Gradient, FuncAge::Curr);

  if (!_c_is_implicit)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adSecondSln&lt;compute_stage&gt;();
  else
    return var-&gt;adSecondSlnNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVectorVariableSecond &amp;
adCoupledVectorSecondTemplate(const std::string &amp; /*var_name*/, unsigned int /*comp = 0*/)
{
  mooseError(
      &quot;Automatic differentiation using second derivatives of vector variables is not implemented.&quot;);
}

template &lt;ComputeStage compute_stage&gt;
const ADVariableValue &amp;
Coupleable::adCoupledDotTemplate(const std::string &amp; var_name, unsigned int comp)
{
  MooseVariable * var = getVar(var_name, comp);
  if (!var)
    return *getADDefaultValue&lt;compute_stage&gt;(var_name);
  checkFuncType(var_name, VarType::Dot, FuncAge::Curr);

  if (_c_nodal)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adUDot&lt;compute_stage&gt;();
  return var-&gt;adUDotNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVectorVariableValue &amp;
Coupleable::adCoupledVectorDotTemplate(const std::string &amp; var_name, unsigned int comp)
{
  VectorMooseVariable * var = getVectorVar(var_name, comp);
  if (!var)
    return *getADDefaultVectorValue&lt;compute_stage&gt;(var_name);
  checkFuncType(var_name, VarType::Dot, FuncAge::Curr);

  if (_c_nodal)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adUDot&lt;compute_stage&gt;();
  return var-&gt;adUDotNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVectorVariableValue &amp;
Coupleable::adCoupledVectorValueTemplate(const std::string &amp; var_name, unsigned int comp)
{
  VectorMooseVariable * var = getVectorVar(var_name, comp);
  if (!var)
    return *getADDefaultVectorValue&lt;compute_stage&gt;(var_name);
  checkFuncType(var_name, VarType::Ignore, FuncAge::Curr);

  if (_c_nodal)
    mooseError(&quot;Not implemented&quot;);
  if (!_c_is_implicit)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adSln&lt;compute_stage&gt;();
  return var-&gt;adSlnNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
const ADVectorVariableGradient &amp;
Coupleable::adCoupledVectorGradientTemplate(const std::string &amp; var_name, unsigned int comp)
{
  VectorMooseVariable * var = getVectorVar(var_name, comp);
  if (!var)
    return getADDefaultVectorGradient&lt;compute_stage&gt;();
  checkFuncType(var_name, VarType::Gradient, FuncAge::Curr);

  if (!_c_is_implicit)
    mooseError(&quot;Not implemented&quot;);

  if (!_coupleable_neighbor)
    return var-&gt;adGradSln&lt;compute_stage&gt;();
  return var-&gt;adGradSlnNeighbor&lt;compute_stage&gt;();
}

template &lt;ComputeStage compute_stage&gt;
ADVariableValue *
Coupleable::getADDefaultValue(const std::string &amp; var_name)
{
  auto default_value_it = _ad_default_value.find(var_name);
  if (default_value_it == _ad_default_value.end())
  {
    auto value = libmesh_make_unique&lt;ADVariableValue&gt;(_coupleable_max_qps,
                                                      _c_parameters.defaultCoupledValue(var_name));
    default_value_it = _ad_default_value.insert(std::make_pair(var_name, std::move(value))).first;
  }

  return default_value_it-&gt;second.get();
}

template &lt;&gt;
VariableValue * Coupleable::getADDefaultValue&lt;RESIDUAL&gt;(const std::string &amp; var_name);

template &lt;ComputeStage compute_stage&gt;
ADVectorVariableValue *
Coupleable::getADDefaultVectorValue(const std::string &amp; var_name)
{
  auto default_value_it = _ad_default_vector_value.find(var_name);
  if (default_value_it == _ad_default_vector_value.end())
  {
    RealVectorValue default_vec;
    for (unsigned int i = 0; i &lt; _c_parameters.numberDefaultCoupledValues(var_name); ++i)
      default_vec(i) = _c_parameters.defaultCoupledValue(var_name, i);
    auto value = libmesh_make_unique&lt;ADVectorVariableValue&gt;(_coupleable_max_qps, default_vec);
    default_value_it =
        _ad_default_vector_value.insert(std::make_pair(var_name, std::move(value))).first;
  }

  return default_value_it-&gt;second.get();
}

template &lt;&gt;
VectorVariableValue * Coupleable::getADDefaultVectorValue&lt;RESIDUAL&gt;(const std::string &amp; var_name);

template &lt;ComputeStage compute_stage&gt;
ADVariableGradient &amp;
Coupleable::getADDefaultGradient()
{
  return _ad_default_gradient;
}

template &lt;&gt;
VariableGradient &amp; Coupleable::getADDefaultGradient&lt;RESIDUAL&gt;();

template &lt;ComputeStage compute_stage&gt;
ADVectorVariableGradient &amp;
Coupleable::getADDefaultVectorGradient()
{
  return _ad_default_vector_gradient;
}

template &lt;&gt;
VectorVariableGradient &amp; Coupleable::getADDefaultVectorGradient&lt;RESIDUAL&gt;();

template &lt;ComputeStage compute_stage&gt;
ADVariableSecond &amp;
Coupleable::getADDefaultSecond()
{
  return _ad_default_second;
}

template &lt;&gt;
VariableSecond &amp; Coupleable::getADDefaultSecond&lt;RESIDUAL&gt;();

template &lt;ComputeStage compute_stage&gt;
const ADVariableValue &amp;
Coupleable::adZeroValueTemplate()
{
  return _ad_zero;
}

template &lt;ComputeStage compute_stage&gt;
const ADVariableGradient &amp;
Coupleable::adZeroGradientTemplate()
{
  return _ad_grad_zero;
}

template &lt;ComputeStage compute_stage&gt;
const ADVariableSecond &amp;
Coupleable::adZeroSecondTemplate()
{
  return _ad_second_zero;
}

template &lt;&gt;
const VariableValue &amp; Coupleable::adZeroValueTemplate&lt;RESIDUAL&gt;();
template &lt;&gt;
const VariableGradient &amp; Coupleable::adZeroGradientTemplate&lt;RESIDUAL&gt;();
template &lt;&gt;
const VariableSecond &amp; Coupleable::adZeroSecondTemplate&lt;RESIDUAL&gt;();
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></section></section></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#b8d34709-da12-41a0-aaed-0e78ccdcfaa5" class="tooltipped" data-position="left" data-tooltip="Optional Coupling">Optional Coupling</a></li><li><a href="#7fd55fa7-db01-4666-8ba8-00b8948c63d9" class="tooltipped" data-position="left" data-tooltip="Coupling of Vectors of Variables">Coupling of Vectors of Variables</a></li><li><a href="#3cf55b35-2d7f-4bb3-bb31-422181418e14" class="tooltipped" data-position="left" data-tooltip="Defaults for Coupling of Vectors of Variables">Defaults for Coupling of Vectors of Variables</a></li><li><a href="#71801ec9-0905-42da-9a55-08047fda5d52" class="tooltipped" data-position="left" data-tooltip="Coupled Solution DOFs">Coupled Solution DOFs</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script>